# Android Project - Part 3: Operations

In this third part of the SwEng project, you will publish your code on a GitHub repository and enable continuous integration on it.

## Set up Git, and create a repository

You will use Git throughout the course for version control, including exams and homeworks.

Git is a version control system for tracking changes in files and coordinating work on those files among multiple people.
It is primarily used for source code management in software development, but it can be used to keep track of changes in any set of files.

First, you need an account on [GitHub](https://github.com), the site that will host the code of your project.
If you don't already have a GitHub account, [here](https://github.com/join) are instructions on how to create one.
Using your real name in your GitHub profile will make debugging easier for the staff in case you run into issues with the class, but this is not required.

You then need to install Git if you do not already have it.

> :information_source: **On macOS or Linux**, Git may already be preinstalled on your system. You can check this by running `git --version`.

> :information_source: **On Windows**, when installing Git, select "Use Git from the Windows Command Prompt" when asked about adjusting your PATH; if you choose one of the other options, whenever this bootcamp talks about "a command line", open Git Bash instead.

> :information_source: If you are asked to generate a new SSH key and add it to the ssh-agent, please follow [GitHub's instructions](https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/).

GitHub provides [setup instructions](https://help.github.com/articles/set-up-git/) to install Git on your computer.

> :warning: In the next step, when doing a "git commit", you will probably open [vim](https://www.vim.org/), a command-line editor that is somewhat hard to use.
> To be able to write content, press `i`. This will enable the editing mode. You can write your commit message. Once your are done with it, press `ESCAPE`, write `:x` and then press `ENTER` to save your changes and quit.
> Alternatively, you can change the editor Git uses by doing `git config --global core.editor <editor>` where on Linux and Mac you might use `nano` for the editor, and on Windows you might use `notepad`.
> If you entered `vim` but just want to quit to use `nano`, press `ESCAPE`, write `:q!` then press `ENTER` to quit.

Now open a command line and cd to where your app is (at the root of the project files, where the main `build.gradle` is located).

To track your program using Git, execute the following commands:

```sh
git init   # Initialize a new repository
git add .  # Add all the files in the current folder to the repository
git commit # Create a first commit
```

The commit you just created contains all of the changes you made; since this is your first commit, those changes are the creation of files.

> :information_source: Usually, creating a git repository is one of the first things you do when starting a project. Therefore, the initial commit is in general not very huge, or it only contains the files generated by your IDE/framework. It is even created for you by some frameworks.

## Ignoring files

Git sees every file in your working copy as one of three things:

1. tracked - a file which has been previously staged or committed;
2. untracked - a file which has not been staged or committed; or
3. ignored - a file which Git has been explicitly told to ignore.

Ignored files are usually build artifacts and machine generated files that can be derived from your repository source or should otherwise not be committed.
In the particular case of this part of the project, these generated files are the **.class** files.

Git uses a special file named **.gitignore** to list all the ignored files.
Note that this is not a file extension; the name must be exactly **.gitignore** and nothing else.
It should be at the root of your repository.
There is no explicit ignore command: you must edit the **.gitignore** file by hand when you have new files that you wish to ignore.

Note that unlike the files it ignores the **.gitignore** file itself must be tracked.

When you create an Android project in Android Studio, a **.gitignore** file is created for you, and it contains the following:

```
*.iml
.gradle
/local.properties
/.idea/caches
/.idea/libraries
/.idea/modules.xml
/.idea/workspace.xml
/.idea/navEditor.xml
/.idea/assetWizardSettings.xml
/.idea/*
.DS_Store
/build
/captures
.externalNativeBuild
.cxx
```

This line tells Git to ignore any files whose name ends with **.iml**, the **.gradle** directory, ...

Usually, your typical `.gitignore` file will exclude all build artifacts (**.class**, **.jar**, **.so**, ...), as well as project dependencies that you manage via a specific build tool (SBT, Gradle, NPM, ...), local IDE configuration (**.eclipse**, **.idea**, **project.iml**, ...) and, most important if your repository is public, **secrets** (**NEVER** upload a private key or API secret on a public facing git repository - thousands of people do that and get hacked, even by automatic bots that look for API keys on GitHub).

> :information_source: Most of the huge libraries and frameworks provide typical `.gitignore` files you can use in your projects, just as Android Studio does.
> Github maintains a collection of such files on [this repo](https://github.com/github/gitignore), feel free to use them!

Before pushing anything to the internet, you want to make sure the API key for the OpenWeatherMap API from the previous part of the project doesn't get published. To do so, you will move it to a new file: first, create an XML file (for example `keys.xml`) in the `app/src/main/res/values` directory.

In this file, write the following:
```xml
<resources>
	<string name="openweather_api_key">YOUR_API_KEY_GOES_HERE</string>
</resources>
```

Replace the text with your actual API key and the name with the name you previously used for your key. Also, **make sure to remove the original line from the original file**. For example, if you declared this key in your `strings.xml`, remove it from there.

Now, you want to add the file to your gitignore, to make sure git doesn't index it.

Add the following line to your `.gitignore`: `/app/src/main/res/values/keys.xml` (change the file name for what you chose earlier).

Now, a file you add to your **.gitignore** isn't removed automatically. To get rid of it, run `git rm --cached <file>`. Here, you want to run `git rm --cached app/src/main/res/values/keys.xml`.

> :information_source: The `--cached` argument tells Git to stop tracking your file while keeping it in the actual filesystem.
> Omitting this argument will cause the file to be removed from the filesystem as well.

Usually, you'd create a new commit to record that the file was removed. But because git keeps track of all your changes, an attacker wanting to steal your private key could just go back to the commit before you removed it. Therefore, you will want to _change_ your previous commit.

To do so, run `git commit --amend`. This will open the editor with the same commit message as before. You can leave it as is.

> :information_source: Amending a commit can be very powerful, but it changes the id of the commit. We will see just after how to synchronize multiple git repositories. Usually, it is a bad practice to amend a commit that you already pushed to a server, as it breaks the history. GitHub, for example, doesn't allow you to push amended commits.

## Publish your repository on GitHub

You will now publish your code to GitHub.
Create a **public** repository on GitHub.
You can name it as you please.
If GitHub offers you to initialize the repository with a README, don't do it.

Publishing code on GitHub requires two steps:
1. Add GitHub as a "remote" to your repository, using the following command: `git remote add origin https://github.com/your-github-username/your-repository-name.git`
2. Push your commits to GitHub: `git push -u origin master`

> :information_source: If you make a mistake in the URL when adding the remote, you can change it with `git remote set-url origin <the correct URL>`

The `git push` command is used to upload local repository content to a remote repository.
Pushing is how you transfer commits from your local repository to a remote repository.
Here, `origin` corresponds to the remote repository you declared using the `git remote add origin <url>` command.
You can have multiple remote repositories, with different names.

> :information_source: You will have to authenticate using your github username and password when you want to interact with the remote.
> By default, Git will "remember" your credentials for 15 minutes - you can change this time using `git config credential.helper cache <timeout in seconds>`.
> Alternatively, you can use a SSH key pair to commit.
> In that case, you'll need to add your public key to your Github account, and replace the remote url with `git@github.com:your-github-username/your-repository-name.git`.
> Take a look at [GitHub's help page](https://help.github.com/articles/connecting-to-github-with-ssh/) for more details.


## Adding and updating files

To demonstrate the power of Git, let's apply some changes to your app. You can, for example, change the greeting message.
Compile your app and run it to validate your changes.

Add the file(s) you just changed:

```sh
git add <file relative path>
```

The `git add` command adds a change in the working directory to the staging area.
It tells Git that you want to include updates to a particular file in the next commit.
However, `git add` doesn't affect the repository by itself; changes are not actually recorded until you commit them.

Commit the changes you just made to your local repository:

```sh
git commit # You can write the commit message inline with the parameter "-m <your commit message>"
```

Commits are like checkpoints you set for yourself.
It is a good practice to keep each commit as small and to the point as possible.
This is especially important when working on a team, since team members often need to look at what their teammates changed.

When it comes to commit messages, beginners (and non-beginners) tend to write anything they have in mind just to get rid of them.
It is actually quite a challenge to write a good commit message.
There is no absolute rule, but there are several guidelines on the internet, such as [Chris Beams' post](https://chris.beams.io/posts/git-commit/) on how to write a Git commit message.

Keep in mind his `Seven rules of a great Git commit message`:

1. Separate subject from body with a blank line
2. Limit the subject line to 50 characters
3. Capitalize the subject line
4. Do not end the subject line with a period
5. Use the imperative mood in the subject line
6. Wrap the body at 72 characters
7. Use the body to explain *what* and *why* vs. *how*


You can now push your commit to your remote repository:
```sh
git push # You only need "-u origin master" the first time you are pushing
```


## Working with multiple Git copies

Git is a useful tool to keep track of your changes, but it's also very powerful when working in teams, to synchronize changes in the code among team members.

As you might have guessed already, a Git repository can have many copies.
Up until now, your repository had two copies: the one on your computer, and the one hosted by GitHub.
When you start working in teams, each member of the team will have a copy of the repository on their computer.
But how can one synchronize their own copy with, for example, the remote?
And what happens when you try to push new commits to a remote without having first synchronized your local copy with that remote?

To simulate the effect of you working with multiple people, you will host two copies of the same repository on your computer.
Open a second command line in another directory (**NOT** inside your git repository).
There, clone your github repository using `git clone https://github.com/your-github-username/your-repository-name.git`.
Git will create a directory with the name of your repository, containing everything you pushed so far.
If you go inside, you will see that git was initialized as well, and `git remote -v` will show you that your GitHub repository has already been added as the `origin` remote.
We will now refer to the directory just created as **the second copy**, while the directory in which you worked earlier will be called **the first copy**.

### Getting commits on remote with `git pull`

First, let's try to change some parts of the code.
Go to the **second copy** and update your app. You can once again change the greeting message, or the weather display.
Save the file then commit and push your changes (refer to the begining of the bootcamp if you can't remember how to do it).
Then, go to the **first copy**.
As you didn't ask anything to Git, the changes you just made are not yet reflected!
To retrieve the changes, open the command line and run `git pull`.
You will now see that the changes you made to the second copy are present in the first one as well.

The `git pull` command works in a similar fashion than the `git push` command.
If you previously ran `git push -u <remote> <branch>`, then you can call `git pull` with no argument.
In the other case, you have to specify the remote and branch using `git pull <remote> <branch>`. Note that when you cloned your repository to create the second copy, Git already linked `origin master` as the default remote and branch for the `master` branch, so you can run `git pull` and `git push` directly.


### Merging different copies

Now, let's see what can happen if you change the code on the two copies _at the same time_.
First, open the **first copy** and change something in your app. For example, you can change the label of a button or its position.
You can now commit and push your updates. Make sure that it has been pushed correctly by checking that you can see your changes on GitHub.

Now, go to the **second copy** and try to do an other change, in the same file as in the first copy.
The changes you did in the **first copy** are indeed not present yet, as you didn't pull.
That's expected, as we want you to see what happens when you do this kind of thing.
After making the changes, commit your code, and _try_ to push it: Git should not allow you to push your changes.

It is normal.

Internally, Git maintains a tree with all the commits of the repository.
Thus, each commit you create has a **parent commit**, the latest commit you had before commiting.
If you try to push a commit that has the same parent commit as a commit that is already on the remote, this will not work, as it would split the tree in two.
To avoid this situation, we will have to merge the changes on the remote and the local changes, to create a new commit combining them, and having two parents.

> :information_source: You can see the history of commits on your copy using `git log`.
> `git log --parents` will also show the hash of the parent commits of each commit in the history!
> You will indeed see that merge commits have two parents, and that normal commits only have one, usually the commit just before them.

When you try to pull commits from the remote while already having locally unpublished commits, git will automatically try to merge them. Run `git pull` to see what happens.

There is a chance here that you'll get a **merge conflict**.
This means that a given file was modified in both versions you're trying to merge.
As a result, Git doesn't know which changes to keep and which changes to remove, and you'll have to tell it what to do.
There are powerful tools out there that can help you resolve merge conflicts. For example, in Android Studio, you can right click on a file having a conflict and go to  "Git > Resolve Conflicts". Here we will show you how to do it using a simple text editor, as this method applies to all kind of files you can store in a Git repository.

When you have a conflict, Git will list all the files that couln't be merged automatically.
Open the file in your favourite text editor to see what happened.
In every place where there is a conflict, you will see something like this:

```
<<<<<<< HEAD

All the code you changed on your local version

=======

All the code that changed on the remote version

>>>>>>> da110d39a9f4494805b6eb5ce1e89ec57d947b04 (<-- a commit hash, obviously different from this example)
```

What you have to do now is to update the files to get them to be exactly what you want them to be.
Here, if you want to keep both changes, you can just remove the `<<<<<<< HEAD`, `=======` and `>>>>>>> da110d39a9f4494805b6eb5ce1e89ec57d947b04` parts.
In other situations, it might be a bit trickier, and dedicated software (sometimes directly included in your IDE) will help you sort it out.

Once everything sounds good to you, run `git add`, `git commit` and `git push` as usual.
You will notice that the `git commit` message is pre-filled with an automatic merge message.
It is good practice to leave it as-is.

> :information_source: Even though you can freely update all the files while merging, it's not a good idea to edit them more than needed to complete the merge.
> Any change you want to make to the code besides from merging should be done in a new commit.
> Otherwise, the commit will confuse anyone looking at it, since they will not expect unrelated changes in a merge commit.

> :information_source: For trivial merges, you will sometimes see your editor directly when running `git pull`.
> This means that the merge didn't require human intervention, and Git just generated the merge commit for you.
> You just have to accept to finish the merge.


### Branches

> :information_source: The commands in this section are provided as an example, but you **don't have to run them**. Just read the section carefully and make sure you understand it!

In huge projects, having everyone work on the same code becomes problematic because their changes will often conflict.
This is where _branches_ come to the rescue.
When you want to develop a new feature, you will create a feature branch, and work there.
When your work is done, you will merge it into master, or open a **pull request** for your changes to be reviewed by members of your team before being approved for merge.
You can learn more about this concept [here](https://www.atlassian.com/git/tutorials/comparing-workflows/feature-branch-workflow).
There are also even more separated variants, like the [git flow](https://nvie.com/posts/a-successful-git-branching-model/) model, but we will not discuss them here.
Let's just see how we can create and switch between branches.
For this part, we won't need to use two copies, so you can remove one of them if you want.

![The git flow model](flow.png)

_The git flow model - [nvie](https://twitter.com/nvie)_

Let's begin with the creation of the branch.
Try to find a good name for it, usually a 2-3 words description of what you're trying to do.
If you want to add a small [Hitchiker's Guide](https://en.wikipedia.org/wiki/The_Hitchhiker%27s_Guide_to_the_Galaxy_(fictional)) in your app, `feature/hitchickers-guide` is a decent name.
To create it, run `git checkout -b feature/hitchickers-guide`.
This will create a new branch and switch to it.
Everything you commit will now be on that branch.

To push the branch to the `origin` remote, you will have to run `git push -u origin feature/hitchickers-guide`.
Again, the `-u origin feature/hitchickers-guide` is only needed the first time you want to push your branch.

If you want to go to another branch, type `git checkout <branch name>`.

When your work is done, you will want to make your changes appear in the main `master` branch.
For that, you have a few options.

The first one is to simply merge the branch.
To do that, go to the `master` branch and run `git merge <the branch you want to merge>`.

The second option is to open a pull request on GitHub.
To do so, follow [GitHub's instructions](https://help.github.com/en/articles/creating-a-pull-request#creating-the-pull-request).
Then go to your repository page and click the `Pull Requests` button.
You will then be able to accept it, which performs the merge for you.
The main advantage of this technique is that opening a pull request (or **PR** for short) opens a discussion in which everyone can review the changes and provide feedback.


## Git Wrap-Up

![In case of fire](fire.png)

_In case of fire - [Louis Michel Couture](https://twitter.com/louim)_

Git is the most widely used version control system, so there is plenty of documentation on the internet.
We have given you a quick intro about how it works, but if you want to learn more, feel free to explore the following links:

- The [Git documentation](https://git-scm.com/doc): a very comprehensive documentation of the software. A web version of the `man` pages of git that you can also get by typing `git help`.
- [git - the simple guide](https://rogerdudler.github.io/git-guide/): a short tutorial to get your hands on git, covers the content of this bootstrap with a few more insights about the internals of git.
- [Commit Often, Perfect Later, Publish Once: Git Best Practices](https://sethrobertson.github.io/GitBestPractices/): an article to help you not only use git correctly, but use it efficiently
- [GitHub Git cheatsheet](https://education.github.com/git-cheat-sheet-education.pdf): a cheat-sheet you can print or keep around to always have the most useful commands at hand

A final note: as with all tools, you'll get most of your experience in using git by... actually using it.
There are a lot of very powerful features you will find handy in some situations.
If you want to do something a bit tricky, like identify which commit introduced a particular bug or regression, don't hesitate and look up in the documentation and try to hack!

> :information_source: If you want to use an advanced Git feature but are not sure about what it could do, create a copy of the entire repository folder first!
> All of the information Git stores is in a folder named `.git` in your repository, thus your folder copy will behave exactly as the original one, and you can switch to it if you accidentally break the original one.

## Continuous Integration with Github Actions

Github Actions is what we call a **continuous integration** service. It is directly integrated into GitHub, which makes it very practical to use.

A CI automates the build of your application: you can define several actions to run either when a button is pressed, or at every push / pull request on a repository. This is a very powerful tool that enables you to, for example, run all your unit tests at every push to make sure you didn't break anything - or at every PR to make sure the PR _won't_ break anything if you merge it. You can also deploy code automatically to a production server, build the binaries for a release...

### Adding encrypted secrets

As was previously said, it is a **bad idea** to upload private keys or API secrets to a public git repository. However, this is quite problematic when using a CI service, as building and running parts of our code requires having access to these secrets. Thankfully, GitHub offers a workaround with [GitHub Secrets](https://docs.github.com/en/free-pro-team@latest/actions/reference/encrypted-secrets).  

For this project, we'll want to create a GitHub secret with the content of your `keys.xml` file. To do so, follow the instructions to create a secret [here](https://docs.github.com/en/free-pro-team@latest/actions/reference/encrypted-secrets). Name your secret `KEYS` and paste the content of your project's `app/src/main/res/values/keys.xml` file in it.

### Setting up your build

GitHub Actions are small YAML files located in a special directory that GitHub reads and understands.
You can define multiple actions on a project, to react differently to different events.

The action you will create for now will simply build your app and test it in the emulator. As you didn't write any test yet, the "test" part will **do nothing** - so for now your action will just check that your app _compiles_. But once we add tests later in the semester, this action will also report if the tests fail.

Actions are simply files in the repository, so you can create them with any test editor. However, GitHub provides a nice enriched interface to create them, so we suggest you use it.

Go to your repository on GitHub and make sure you are logged in to your account. You should see an "Actions" tab, click it.

On the next page, click "Skip this and set up a workflow yourself".

GitHub provides a lot of workflows for common use-cases, but doesn't explicitly recommend anything for Android apps, so we will build it ourselves.

GitHub actions use **containers** that run in the Cloud (Microsoft Azure, as far as we know). Containers are like small VMs that can be quickly deployed and that run some software in isolation. In GitHub actions, you specify which kind of container you want to run (`ubuntu`, `macos`, ...), and then you import some action templates that provide you with tools to build your project. We will see how this works now.

On the page that opens, set the name of your action file at the top - something like "android.yml" would work just fine.

Clear the large code editor below, and copy/paste the following code:

```yaml
name: Android Workflow

on: [push, pull_request]

jobs:
  test:
    runs-on: macos-latest
    steps:
    - name: checkout
      uses: actions/checkout@v2

    - name: add keys
      env:
        KEYS: ${{ secrets.KEYS }}
      run: echo $KEYS > app/src/main/res/values/keys.xml

    - name: Make gradlew executable
      run: chmod +x ./gradlew

    - name: run tests
      uses: reactivecircus/android-emulator-runner@v2
      with:
        api-level: 29
        script: ./gradlew connectedCheck
```

We will now comment all the lines in this workflow.

 - First comes the `name` of your workflow. You can choose anything you like for this.
 - Then comes the list of events that can trigger the action. Here, we defined `[push, pull_request]`. This means this action will run every time you either pull or open/update a pull request. You can see more examples of triggers in the [GitHub Documentation](https://docs.github.com/en/free-pro-team@latest/actions/reference/events-that-trigger-workflows)
 - Then you have a list of `jobs`. In this build, we only have one `job` called `test`. Each job defines multiple parameters:
 	- First, you have the `runs-on` paremeter, which defines the base container to use. Here, we want to run on `macos` because it enables hardware acceleration, which we need to run the emulator. We specifiy `macos-latest` to use the latest version of macos, as we don't care about the specific version used in the container.
 	- Then, we have a list of `steps` to run in the build. They are ran one after the other. A typical `step` has a name, `uses` one or multiple templates, and specifies some parameters defined by the template.
 		+ The first action uses the standard template `actions/checkout@v2` (which corresponds to the tag `v2` on GitHub repository `actions/checkout` - actions are repositories themselves!). This action simply clones the repository and sets the current working repository in it.
 		+ The second action adds back the secret keys that were previously omitted from the repository.
		First, the `KEYS` secret that we previously stored is accessed, and then copied to the `app/src/main/res/values/keys.xml` file. You can find out more about using secrets in a workflow [here](https://docs.github.com/en/free-pro-team@latest/actions/reference/encrypted-secrets#using-encrypted-secrets-in-a-workflow).
 		+ Finally, you have the action running the tests. This action uses the template `reactivecircus/android-emulator-runner@v2`. This template sets-up an emulator for you, and then lets you execute any script you like. Here, our `script` is a command that builds the app and executes the tests on an emulator. The documentation of this action can be found in the [GitHub Actions Marketplace](https://github.com/marketplace/actions/android-emulator-runner). You will probably want to have a look at this at some point in SDP!

Now, you can commit the file using the dedicated button. After a few seconds, going back to the **Actions** tab you should see an action with the name you chose earlier. If everything goes fine, it should be running or scheduled to run soon. After a few minutes (~ 5-7mn) you should get a successfull result and a nice green check mark.Now, you can commit the file using the dedicated button. After a few seconds, going back to the **Actions** tab you should see an action with the name you chose earlier. If everything goes fine, it should be running or scheduled to run soon. After a few minutes (~ 5-7mn) you should get a successfull result and a nice green check mark.

If the build fails, you can check the logs to see what went wrong and fix it. If you still can't get it to work, please ask a TA.

That's all for today!
